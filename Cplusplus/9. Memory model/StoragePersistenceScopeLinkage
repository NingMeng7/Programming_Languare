持续性 ~ 变量/函数的生存周期
链接性,作用域 ~ 变量/函数的可见范围
(1) C++中数据存储有多种选择

  (a) 可以选择数据保留在内存中的时间长度(存储持续性)
  (b) 程序哪一部分可以访问数据(作用域与链接)
  (c) new动态分配内存，动态new

(2) 单独编译

C++鼓励程序员将组件函数放在独立的文件，编译器可以单独编译这些文件，再通过链接来使得它们组成可执行的程序，一般来说，为了不因为将一个程序放在多个文件中引发
新的问题，考虑将原来的程序分成三个部分:

a)  头文件：包含结构声明和使用这些结构的原型
b)  源代码文件:  包含与结构有关的函数的代码
c)  源代码文件:  包含调用与结构有关的函数的代码

RK: 头文件中通常不加入函数定义与变量声明，包含头文件的指令实际上最终是把头文件中的代码替换#include指令，如果加入这两个内容，如果在同一个程序的两个文件
都包含这个头文件，将会导致出错。
通常头文件包括的内容有:

a)  函数原型
b)  #define 或者 const 定义的符号常量
c)  结构声明
d)  类声明
e)  模版声明
f)  内联函数

其中，模版声明和结构声明并不创建变量，而只是在源代码文件中声明结构变量或者函数的时候指示编译器如何创建该结构变量或者调用相匹配的函数定义。

(3) #include <>:  C++将在存储标准头文件的主机系统的文件系统中查找。
    #include "":  编译器优先查找当前工作目录或者源代码目录，再到存储标准头文件的主机系统的文件系统中查找。
    只需要将源代码文件加入到项目中而不需要加入头文件，不要使用#include来包含源代码文件。

(4) 作用域：scope描述了名称在文件(翻译单元)的多大范围内可见。
    链接性: linkage描述了名称如何在不同单元间共享。
      (i) 外部：文件间共享
      (ii) 内部：文件中的函数间共享
      (iii) 无链接性:不能共享
    
(5) 自动存储持续性

a)  自动存储持续性: 在函数定义中声明的变量(包括函数参数)的存储持续性为自动的，它们在程序开始执行其所属的代码块时被创建，在函数或者代码块被执行完的时候
被释放，注意，当代码块被执行的时候为变量分配内存，而变量的作用域的起点是其声明位置。
int main()
{
  int teledeli = 5;
  {                           // websight allocated
    cout << "Hello" << endl;
    int websight = -2;  //  websight scope begin
    cout << websight << ' ' << teledeli << endl;
  } //  websiht expires
    cout << teledeli << endl;
} //  teledeli expires

b)  在程序执行的整个周期中，自动存储持续性变量的数目将会不断增减，因此编译器将会分配一段内存作为栈对变量进行管理，遵循LIFO规则。

c)  局部变量将会对全局变量进行屏蔽。

(5) 静态持续变量

a)  静态变量的数目在程序运行期间不变，因此编译器将会分配固定的内存块来存储所有的静态变量。
b)  ### 静态变量如果不显示初始化，将会被默认设为0，对数组和结构体，编译器将会把全部位都设置为0 ###
c)  外部链接性(可在其他文件中访问): 在代码块外声明变量
    内部链接性(只能在当前文件中访问):在代码块的外面声明它并使用static限定符,(以及const)
    无链接性(只能在当前函数或者代码块中访问):在代码块内声明它，并且使用static限定符(注意，在代码块中但不使用static限定符的情况是自动持续变量)
    
int global = 1000;
static int one_file = 50;
int main()
{
  ...
}
void fun1(int n)
{
  static int count = 0;
  int llama = 0;
}
void fun2(int q)
{
  ...
}

global: 整个文件，并且可以在程序的其他文件中使用它
one_file：整个文件，但是只能在当前文件使用它
count：  无链接性，局部静态变量，当所在代码块不被调用的时候，count也留在内存中

(6) C++中有一个单定义规则，要求变量只能有一次定义，但是对于外部变量，每一个使用它的文件都要声明它。
    C++提供了两种变量声明，一种是defining declaration: 给变量分配存储空间
                         一种是referencing declaration: 引用声明: 不给变量分配存储空间，而是引用已有的变量
    
    double up;            //  definition,up is 0
    extern int belm;      //  blem defined elsewhere
    extern char gr = 'z'; //  definiton,because initialized


(8) 说明符和限定符

a)  storage class specifier

auto: C++11中不再是说明符
register: C++11中显示地说明变量是自动的，保留的一大理由是为了以前写的代码还能跑
static: 对作用域为整个文件的声明使用static是说明内部链接性，而对局部变量来说，是为了说明存储持续性是静态的
extern: 引用声明
thread_local: 变量的持续性与其所属线程持续性相同，thread_local之余线程如同常规静态变量之于整个程序。
mutable: 即使结构(类)变量为const，某个成员也可以被进行修改
struct data {
  char name[30];
  mutable int accesses;
};
const data veep = {"abc", 0};
strcpy(veep.name, "def"); //  not allowed
veep.accesses++;  //allowed

b)  cv限定符：const & volatile
const:  const限定符对全局变量使用会导致链接性变为内部，这使得我们可以把const常量定义放在头文件中，而不怕因此违反单定义规则(注意，并不是说不能有同
        名的变量，但是对一个外部链接的全局变量而言，不能多次定义)
        如果想要让某个常量的链接性是外部的，可以用exten说明符， extern const int states = 50;  在这种情况下，每个使用states的文件都需要用extern
        进行引用声明，与常规的外部链接变量比起来，在定义的时候，也需要加上extern.

(9) 函数的存储连续性与链接性

(a) 存储连续性：C++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性自动为静态存储持续性，在整个程序执行期间都一直存在。
(b) 函数链接性: 在默认情况下，函数的链接性为外部的，即可以在文件间进行共享，可以用关键字 static 使得函数的链接性变为内部的，使得函数只能在一个函数中
    使用，函数的原型和定义必须同时加上关键字 static。
(c) 内联函数不受单定义规则的限制，因此内联函数能够放在头文件中，但是同一个函数的所有内联定义都必须相同。



静态函数和静态变量将会覆盖外部定义

(10)

(a) 常规的new申请的地址位于堆中。
(b) 定位new运算符不追踪参数指定的内存是否已经被使用，也不查找未使用的内存块，这些内存管理的责任被交给程序员。
(c) delete只能用于：指向常规new运算符分配的堆内存，因此不能对定位运算符指定的空间进行delete操作





